colnames(noise_loc1[[i]]) = c('x', 'y', 'noise')
}
#read in traps location
traps_loc1 = vector('list', n.array1)
for(i in 1:n.array1){
traps_loc1[[i]] = read.csv(paste0(pre_fix, "traps1/trap", i, ".csv"), header = T)
colnames(traps_loc1[[i]]) = c('x', 'y')
}
#generate "mask" data based on traps locations
mask_loc1 = create.mask(traps_loc1, buffer = 350)
#find the closest location which contains noise value for each mask point
df_noise1 = vector('list', n.array1)
for(i in 1:n.array1){
tem_mask = mask_loc1[[i]]
tem_noise = noise_loc1[[i]]
tem = RANN::nn2(data = tem_noise[,1:2], query = tem_mask, k = 10)
w = (1/tem$nn.dists) ^ 2
w = w / apply(w, 1, sum)
matrix_noise = matrix(tem_noise$noise[tem$nn.idx], nrow = nrow(tem_mask))
df_noise1[[i]] = data.frame(mask = 1:nrow(tem_mask), noise = apply(matrix_noise * w, 1, sum))
}
n.sessions1 = max(df_season1$Night)
traps1 = vector('list', n.sessions1)
mask1 = vector('list', n.sessions1)
cov_noise1 = vector('list', n.sessions1)
for(s in 1:n.sessions1){
a = df_season1$Array[s]
traps1[[s]] = traps_loc1[[a]]
mask1[[s]] = mask_loc1[[a]]
cov_noise1[[s]] = df_noise1[[a]]
cov_noise1[[s]]$session = s
}
cov_noise1 = do.call('rbind', cov_noise1)
#deal with capture history
raw_dat1 = read.csv(paste0(pre_fix, 'capt1.csv'), header = T)
capture_history1 = data.frame(session = raw_dat1[,2], ID = raw_dat1[,3], occasion = 1, trap = raw_dat1[,5],
animal_ID = raw_dat1[,6], ss = raw_dat1[,7])
#extract broken detectors for each session and modify the capture history and 'trap' list
broken_dets = strsplit(df_season1$Broken, ',')
tem_capt_history = vector('list', n.sessions1)
for(s in 1:n.sessions1){
tem_capt_history[[s]] = subset(capture_history1, session == s)
#if its first element is not "0", there is at least one broken detector in this session
if(!(broken_dets[[s]] == '0')[1]){
#re-assign the indices in the capture history
if(nrow(tem_capt_history[[s]]) != 0){
n.traps.og = nrow(traps1[[s]])
tem_broken_dets = as.numeric(broken_dets[[s]])
tem_capt_history[[s]]$trap = re_assign_trap(tem_capt_history[[s]]$trap, n.traps.og, tem_broken_dets)
}
#take out the broken detectors from the traps list
traps1[[s]] = traps1[[s]][-as.numeric(broken_dets[[s]]),]
}
}
capture_history1 = do.call('rbind', tem_capt_history)
tem_capt_history[[23]]
df_season2 = read.csv(paste0(pre_fix, 'sessions2.csv'), header = T, stringsAsFactors = F)
df_season2 = df_season2[order(df_season2$Night),]
n.array2 = max(df_season2$Array)
n.array2
df_season2
#a function to re-assign trap id when there is any broken detector in one session
re_assign_trap = function(id_og, n_traps_og, broken){
df_convert = data.frame(og = 1:n_traps_og)
df_convert = subset(df_convert, !og %in% as.numeric(broken))
df_convert$new = 1:nrow(df_convert)
#merge will disrupt order, use "index" to record the order
do_convert = data.frame(og = id_og, index = seq(length(id_og)))
do_convert = merge(do_convert, df_convert, by = 'og', all.x = TRUE, sort = FALSE)
do_convert = do_convert[order(do_convert$index),]
return(do_convert$new)
}
pre_fix = "G:/work/ben/owl_study/"
df_season2 = read.csv(paste0(pre_fix, 'sessions2.csv'), header = T, stringsAsFactors = F)
df_season2 = df_season2[order(df_season2$Night),]
n.array2 = max(df_season2$Array)
#read in noise values with locations
noise_loc2 = vector('list', n.array2)
for(i in 1:n.array2){
noise_loc2[[i]] = read.csv(paste0(pre_fix, "mask2/mask", i, ".csv"), header = T)
colnames(noise_loc2[[i]]) = c('x', 'y', 'noise')
}
#read in traps location
traps_loc2 = vector('list', n.array2)
for(i in 1:n.array2){
traps_loc2[[i]] = read.csv(paste0(pre_fix, "traps2/trap", i, ".csv"), header = T)
colnames(traps_loc2[[i]]) = c('x', 'y')
}
#generate "mask" data based on traps locations
mask_loc2 = create.mask(traps_loc2, buffer = 350)
#find the closest location which contains noise value for each mask point
df_noise2 = vector('list', n.array2)
for(i in 1:n.array2){
tem_mask = mask_loc2[[i]]
tem_noise = noise_loc2[[i]]
tem = RANN::nn2(data = tem_noise[,1:2], query = tem_mask, k = 10)
w = (1/tem$nn.dists) ^ 2
w = w / apply(w, 1, sum)
matrix_noise = matrix(tem_noise$noise[tem$nn.idx], nrow = nrow(tem_mask))
df_noise2[[i]] = data.frame(mask = 1:nrow(tem_mask), noise = apply(matrix_noise * w, 1, sum))
}
#convert the data in "array" to data in "session"
n.sessions2 = max(df_season2$Night)
traps2 = vector('list', n.sessions2)
mask2 = vector('list', n.sessions2)
cov_noise2 = vector('list', n.sessions2)
max(df_season2$Night)
for(s in 1:n.sessions2){
a = df_season2$Array[s]
traps2[[s]] = traps_loc2[[a]]
mask2[[s]] = mask_loc2[[a]]
cov_noise2[[s]] = df_noise2[[a]]
cov_noise2[[s]]$session = s
}
cov_noise1 = do.call('rbind', cov_noise1)
cov_noise2 = do.call('rbind', cov_noise2)
#deal with capture history
raw_dat2 = read.csv(paste0(pre_fix, 'capt2.csv'), header = T)
View(raw_dat2)
capture_history2 = data.frame(session = raw_dat2[,2], ID = raw_dat2[,3], occasion = 1, trap = raw_dat2[,5],
animal_ID = raw_dat2[,6], ss = raw_dat2[,7])
#extract broken detectors for each session and modify the capture history and 'trap' list
broken_dets = strsplit(df_season2$Broken, ',')
tem_capt_history = vector('list', n.sessions2)
for(s in 1:n.sessions2){
tem_capt_history[[s]] = subset(capture_history2, session == s)
#if its first element is not "0", there is at least one broken detector in this session
if(!(broken_dets[[s]] == '0')[1]){
#re-assign the indices in the capture history
if(nrow(tem_capt_history[[s]]) != 0){
n.traps.og = nrow(traps2[[s]])
tem_broken_dets = as.numeric(broken_dets[[s]])
tem_capt_history[[s]]$trap = re_assign_trap(tem_capt_history[[s]]$trap, n.traps.og, tem_broken_dets)
}
#take out the broken detectors from the traps list
traps2[[s]] = traps2[[s]][-as.numeric(broken_dets[[s]]),]
}
}
capture_history2 = do.call('rbind', tem_capt_history)
#a function to re-assign trap id when there is any broken detector in one session
re_assign_trap = function(id_og, n_traps_og, broken){
df_convert = data.frame(og = 1:n_traps_og)
df_convert = subset(df_convert, !og %in% as.numeric(broken))
df_convert$new = 1:nrow(df_convert)
#merge will disrupt order, use "index" to record the order
do_convert = data.frame(og = id_og, index = seq(length(id_og)))
do_convert = merge(do_convert, df_convert, by = 'og', all.x = TRUE, sort = FALSE)
do_convert = do_convert[order(do_convert$index),]
return(do_convert$new)
}
library(devtools)
library(RANN)
load_all("G:/github/ascr/")
pre_fix = "G:/work/ben/owl_study/"
#for season 1
df_season1 = read.csv(paste0(pre_fix, 'sessions1.csv'), header = T, stringsAsFactors = F)
df_season1 = df_season1[order(df_season1$Night),]
n.array1 = max(df_season1$Array)
#read in noise values with locations
noise_loc1 = vector('list', n.array1)
for(i in 1:n.array1){
noise_loc1[[i]] = read.csv(paste0(pre_fix, "mask1/mask", i, ".csv"), header = T)
colnames(noise_loc1[[i]]) = c('x', 'y', 'noise')
}
#read in traps location
traps_loc1 = vector('list', n.array1)
for(i in 1:n.array1){
traps_loc1[[i]] = read.csv(paste0(pre_fix, "traps1/trap", i, ".csv"), header = T)
colnames(traps_loc1[[i]]) = c('x', 'y')
}
#generate "mask" data based on traps locations
mask_loc1 = create.mask(traps_loc1, buffer = 350)
#find the closest location which contains noise value for each mask point
df_noise1 = vector('list', n.array1)
for(i in 1:n.array1){
tem_mask = mask_loc1[[i]]
tem_noise = noise_loc1[[i]]
tem = RANN::nn2(data = tem_noise[,1:2], query = tem_mask, k = 10)
w = (1/tem$nn.dists) ^ 2
w = w / apply(w, 1, sum)
matrix_noise = matrix(tem_noise$noise[tem$nn.idx], nrow = nrow(tem_mask))
df_noise1[[i]] = data.frame(mask = 1:nrow(tem_mask), noise = apply(matrix_noise * w, 1, sum))
}
#convert the data in "array" to data in "session"
n.sessions1 = max(df_season1$Night)
traps1 = vector('list', n.sessions1)
mask1 = vector('list', n.sessions1)
cov_noise1 = vector('list', n.sessions1)
for(s in 1:n.sessions1){
a = df_season1$Array[s]
traps1[[s]] = traps_loc1[[a]]
mask1[[s]] = mask_loc1[[a]]
cov_noise1[[s]] = df_noise1[[a]]
cov_noise1[[s]]$session = s
}
cov_noise1 = do.call('rbind', cov_noise1)
#deal with capture history
raw_dat1 = read.csv(paste0(pre_fix, 'capt1.csv'), header = T)
capture_history1 = data.frame(session = raw_dat1[,2], ID = raw_dat1[,3], occasion = 1, trap = raw_dat1[,5],
animal_ID = raw_dat1[,6], ss = raw_dat1[,7])
#extract broken detectors for each session and modify the capture history and 'trap' list
broken_dets = strsplit(df_season1$Broken, ',')
tem_capt_history = vector('list', n.sessions1)
for(s in 1:n.sessions1){
tem_capt_history[[s]] = subset(capture_history1, session == s)
#if its first element is not "0", there is at least one broken detector in this session
if(!(broken_dets[[s]] == '0')[1]){
#re-assign the indices in the capture history
if(nrow(tem_capt_history[[s]]) != 0){
n.traps.og = nrow(traps1[[s]])
tem_broken_dets = as.numeric(broken_dets[[s]])
tem_capt_history[[s]]$trap = re_assign_trap(tem_capt_history[[s]]$trap, n.traps.og, tem_broken_dets)
}
#take out the broken detectors from the traps list
traps1[[s]] = traps1[[s]][-as.numeric(broken_dets[[s]]),]
}
}
capture_history1 = do.call('rbind', tem_capt_history)
#for season 2
df_season2 = read.csv(paste0(pre_fix, 'sessions2.csv'), header = T, stringsAsFactors = F)
df_season2 = df_season2[order(df_season2$Night),]
n.array2 = max(df_season2$Array)
#read in noise values with locations
noise_loc2 = vector('list', n.array2)
for(i in 1:n.array2){
noise_loc2[[i]] = read.csv(paste0(pre_fix, "mask2/mask", i, ".csv"), header = T)
colnames(noise_loc2[[i]]) = c('x', 'y', 'noise')
}
#read in traps location
traps_loc2 = vector('list', n.array2)
for(i in 1:n.array2){
traps_loc2[[i]] = read.csv(paste0(pre_fix, "traps2/trap", i, ".csv"), header = T)
colnames(traps_loc2[[i]]) = c('x', 'y')
}
#generate "mask" data based on traps locations
mask_loc2 = create.mask(traps_loc2, buffer = 350)
#find the closest location which contains noise value for each mask point
df_noise2 = vector('list', n.array2)
for(i in 1:n.array2){
tem_mask = mask_loc2[[i]]
tem_noise = noise_loc2[[i]]
tem = RANN::nn2(data = tem_noise[,1:2], query = tem_mask, k = 10)
w = (1/tem$nn.dists) ^ 2
w = w / apply(w, 1, sum)
matrix_noise = matrix(tem_noise$noise[tem$nn.idx], nrow = nrow(tem_mask))
df_noise2[[i]] = data.frame(mask = 1:nrow(tem_mask), noise = apply(matrix_noise * w, 1, sum))
}
#convert the data in "array" to data in "session"
n.sessions2 = max(df_season2$Night)
traps2 = vector('list', n.sessions2)
mask2 = vector('list', n.sessions2)
cov_noise2 = vector('list', n.sessions2)
for(s in 1:n.sessions2){
a = df_season2$Array[s]
traps2[[s]] = traps_loc2[[a]]
mask2[[s]] = mask_loc2[[a]]
cov_noise2[[s]] = df_noise2[[a]]
cov_noise2[[s]]$session = s
}
cov_noise2 = do.call('rbind', cov_noise2)
#deal with capture history
raw_dat2 = read.csv(paste0(pre_fix, 'capt2.csv'), header = T)
capture_history2 = data.frame(session = raw_dat2[,2], ID = raw_dat2[,3], occasion = 1, trap = raw_dat2[,5],
animal_ID = raw_dat2[,6], ss = raw_dat2[,7])
#extract broken detectors for each session and modify the capture history and 'trap' list
broken_dets = strsplit(df_season2$Broken, ',')
tem_capt_history = vector('list', n.sessions2)
for(s in 1:n.sessions2){
tem_capt_history[[s]] = subset(capture_history2, session == s)
#if its first element is not "0", there is at least one broken detector in this session
if(!(broken_dets[[s]] == '0')[1]){
#re-assign the indices in the capture history
if(nrow(tem_capt_history[[s]]) != 0){
n.traps.og = nrow(traps2[[s]])
tem_broken_dets = as.numeric(broken_dets[[s]])
tem_capt_history[[s]]$trap = re_assign_trap(tem_capt_history[[s]]$trap, n.traps.og, tem_broken_dets)
}
#take out the broken detectors from the traps list
traps2[[s]] = traps2[[s]][-as.numeric(broken_dets[[s]]),]
}
}
capture_history2 = do.call('rbind', tem_capt_history)
max(capture_history2$session)
length(traps2)
pre_fix
###########################################################################################################
saveRDS(list(capt_history = capture_history1, cov_noise = cov_noise1, traps = traps1, mask = mask1),
file = paste0(pre_fix, "dat1"))
saveRDS(list(capt_history = capture_history2, cov_noise = cov_noise2, traps = traps2, mask = mask2),
file = paste0(pre_fix, "dat2"))
pre_fix = "G:/work/ben/owl_study/"
tem = readRDS(paste0(pre_fix, 'dat1'))
View(tem)
Sys.setenv(package_dir = "G:/github/ascr/",
work_dir = "G:/work/ben/owl_study/")
Sys.getenv('package_dir')
library(devtools)
load_all()
getwd()
system.file(package = "ascr")
compile.ascr()
library(devtools)
load_all()
compile.ascr()
compile.ascr()
compile.ascr()
compile.ascr()
compile.ascr()
library('devtools')
load_all()
demo_sim_ss_log = readRDS('./inst/demo_sim_ss_log')
true_values = demo_sim_ss_log$param
for(i in names(true_values)){
if(length(true_values[[i]]) == 1) true_values[[i]] = link.fun(default.link(i), true_values[[i]])
}
set.seed(810)
n.rand = 100
sim_out = with(demo_sim_ss_log, sim.capt(detfn = detfn, param = param, traps = traps, mask = mask,
ss.opts = ss.opts, n.sessions = n.sessions, n.rand = n.rand))
sim_b0.ss = numeric(n.rand)
sim_b1.ss = numeric(n.rand)
sim_sigma.ss = numeric(n.rand)
sim_D = numeric(n.rand)
sim_mu = numeric(n.rand)
pb = utils::txtProgressBar(1, n.rand, style = 3)
for(i in 1:n.rand){
if(nrow(sim_out[[i]]) > 0){
capt = create.capt(sim_out[[i]], demo_sim_ss_log$traps)
fit = fit_og(capt, traps = demo_sim_ss_log$traps, mask = demo_sim_ss_log$mask, detfn = demo_sim_ss_log$detfn
, ss.opts = demo_sim_ss_log$ss.opts)
tem = coef(fit)
sim_b0.ss[i] = tem['b0.ss_link']
sim_b1.ss[i] = tem['b1.ss_link']
sim_sigma.ss[i] = tem['sigma.ss_link']
sim_D[i] = tem['D_link']
sim_mu[i] = tem['mu_link']
}
utils::setTxtProgressBar(pb, i)
}
close(pb)
hist(sim_b0.ss, main = 'b0.ss_link simulation')
abline(v = true_values$b0.ss, col = 2)
hist(sim_b1.ss, main = 'b1.ss_link simulation')
abline(v = true_values$b1.ss, col = 2)
hist(sim_sigma.ss, main = 'sigma.ss_link simulation')
abline(v = true_values$sigma.ss, col = 2)
hist(sim_D, main = 'D_link simulation')
abline(v = true_values$D, col = 2)
hist(sim_mu, main = 'mu_link simulation')
abline(v = true_values$mu, col = 2)
tem = sim_out[[1]]
tem1 = demo_fit('ind_ss', fit = FALSE)
tem1$data
tem1 = tem1$data
View(tem1)
ind_ss_log = vector('list', 15)
names(ind_ss_log) = names(tem1)
tem1[["captures"]]
ind_ss_log$captures = tem
tem
ind_ss_log$traps = demo_sim_ss_log$traps
ind_ss_log$mask = demo_sim_ss_log$mask
ind_ss_log$detfn = 'ss'
ind_ss_log$ss.opts = demo_sim_ss_log$ss.opts
ind_ss_log$capt_input = create.capt(ind_ss_log$captures, ind_ss_log$traps)
ind_ss_log$sound.speed = 331
ind_ss_log$dev = FALSE
View(ind_ss_log)
model_output = with(ind_ss_log, fit_og(capt = capt_input, traps = traps, mask = mask, sv = sv_input, fix = fix_input,
detfn = detfn, local = local_input, bounds = bounds_input, cue.rates = cue.rates,
sound.speed = sound.speed, ss.opts = ss.opts, survey.length = survey.length,
par.extend = par.extend, dev = dev))
View(tem1)
ind_ss_log$local_input = FALSE
model_output = with(ind_ss_log, fit_og(capt = capt_input, traps = traps, mask = mask, sv = sv_input, fix = fix_input,
detfn = detfn, local = local_input, bounds = bounds_input, cue.rates = cue.rates,
sound.speed = sound.speed, ss.opts = ss.opts, survey.length = survey.length,
par.extend = par.extend, dev = dev))
use_data(ind_ss_log)
document()
tem = demo_fit('ind_ss_log')
View(ind_ss_log)
tem$model_output$n.sessions
range(tem$model_output$output.tmb$data.dists.thetas$dx)
demo_sim_ss_sp = readRDS('./inst/demo_sim_ss_log')
View(demo_sim_ss_sp)
demo_sim_ss_sp$ss.opts
demo_sim_ss_sp$ss.opts$ss.link = 'spherical'
demo_sim_ss_sp$param
20 * log10(24)
f = function(x) det_prob('ss', det_par = list(b0.ss = 100, b1.ss = 0.1), dx = x, ss.link = 'spherical')
curve(f, from = 0, to = 25)
load_all()
f = function(x) det_prob('ss', det_par = list(b0.ss = 100, b1.ss = 0.1), dx = x, ss.link = 'spherical')
curve(f, from = 0, to = 25)
demo_sim_ss_sp$param
demo_sim_ss_sp$param$b0.ss = 100
demo_sim_ss_sp$ss.opts$cutoff = 75
true_values = demo_sim_ss_sp$param
for(i in names(true_values)){
if(length(true_values[[i]]) == 1) true_values[[i]] = link.fun(default.link(i), true_values[[i]])
}
true_values
log(100)
set.seed(810)
n.rand = 100
sim_out = with(demo_sim_ss_sp, sim.capt(detfn = detfn, param = param, traps = traps, mask = mask,
ss.opts = ss.opts, n.sessions = n.sessions, n.rand = n.rand))
saveRDS(demo_sim_ss_sp, 'inst/demo_sim_ss_sp')
sim_b0.ss = numeric(n.rand)
sim_b1.ss = numeric(n.rand)
sim_sigma.ss = numeric(n.rand)
sim_D = numeric(n.rand)
sim_mu = numeric(n.rand)
pb = utils::txtProgressBar(1, n.rand, style = 3)
for(i in 1:n.rand){
if(nrow(sim_out[[i]]) > 0){
capt = create.capt(sim_out[[i]], demo_sim_ss_sp$traps)
fit = fit_og(capt, traps = demo_sim_ss_sp$traps, mask = demo_sim_ss_sp$mask, detfn = demo_sim_ss_sp$detfn
, ss.opts = demo_sim_ss_sp$ss.opts)
tem = coef(fit)
sim_b0.ss[i] = tem['b0.ss_link']
sim_b1.ss[i] = tem['b1.ss_link']
sim_sigma.ss[i] = tem['sigma.ss_link']
sim_D[i] = tem['D_link']
sim_mu[i] = tem['mu_link']
}
utils::setTxtProgressBar(pb, i)
}
close(pb)
hist(sim_b0.ss, main = 'b0.ss_link simulation')
abline(v = true_values$b0.ss, col = 2)
hist(sim_b1.ss, main = 'b1.ss_link simulation')
abline(v = true_values$b1.ss, col = 2)
hist(sim_sigma.ss, main = 'sigma.ss_link simulation')
abline(v = true_values$sigma.ss, col = 2)
hist(sim_D, main = 'D_link simulation')
abline(v = true_values$D, col = 2)
hist(sim_mu, main = 'mu_link simulation')
abline(v = true_values$mu, col = 2)
log(0.1)
log(0.05)
log(0.01)
log(0.0001)
exp(-20)
demo_sim_ss_sp$ss.opts
i = 7
capt = create.capt(sim_out[[i]], demo_sim_ss_sp$traps)
fit = fit_og(capt, traps = demo_sim_ss_sp$traps, mask = demo_sim_ss_sp$mask, detfn = demo_sim_ss_sp$detfn
, ss.opts = demo_sim_ss_sp$ss.opts)
coef(fit)
log(0.1)
ind_ss_sp = ind_ss_log
ind_ss_sp$captures = sim_out[[7]]
ind_ss_sp$capt_input = capt
ind_ss_sp$ss.opts
ind_ss_sp$ss.opts$ss.link = "spherical"
ind_ss_sp$ss.opts = demo_sim_ss_sp$ss.opts
use_data(ind_ss_sp)
document()
library(devtools)
load_all()
load_all()
load_all()
show_demo_options()
demo_options = show_demo_options()
o_demo = demo_fit(demo_options[1])
o_sim = sim_study(demo_options[1], fit = T)
coef(o_demo$model_output)
coef(o_sim$sim_fit)
coef(o_demo$model_output) == coef(o_sim$sim_fit)
all(coef(o_demo$model_output) == coef(o_sim$sim_fit))
result = logical(length(demo_options))
names(result) = demo_options
demo_options
result = logical(length(demo_options))
names(result) = demo_options
for(i in demo_options){
o_demo = demo_fit(i)
o_sim = sim_study(i, fit = T)
result[i] = all(coef(o_demo$model_output) == coef(o_sim$sim_fit))
}
result
result = vector('list', length(demo_options))
names(result) = demo_options
result = vector('list', length(demo_options))
names(result) = demo_options
for(i in demo_options){
o_demo = demo_fit(i)
result[[i]] = o_demo$model_output
}
coef(result$bearing_dist_hn)
coef(result$bearing_dist_hn, types = 'fitted')
coef(result$dist_hn, types = 'fitted')
coef(result$bearing_hn, types = 'fitted')
coef(result$ihd, types = 'fitted')
coef(result$ihd_ext, types = 'fitted')
coef(result$mul_ses, types = 'fitted')
coef(result$mul_ses_ext, types = 'fitted')
log(33.8)
log(14.8)
coef(result$simple_hhn, types = 'fitted')
coef(result$hhn_cue, types = 'fitted')
coef(result$simple_hr, types = 'fitted')
coef(result$ss, types = 'fitted')
coef(result$ss_toa, types = 'fitted')
coef(result$ind_bearing_dist, types = 'fitted')
coef(result$ind_toa_hhn, types = 'fitted')
coef(result$ind_ss, types = 'fitted')
coef(result$ind_ss_log, types = 'fitted')
log(92)
coef(result$ind_ss_sp, types = 'fitted')
